From 7fd57fc856314a6dd00204de1b0bed71d0240250 Mon Sep 17 00:00:00 2001
From: nxa15299 <Heinz.Wrobel@nxp.com>
Date: Thu, 18 Jan 2018 14:29:57 +0100
Subject: [PATCH 1/2] pseudo: To support chroot exec paths properly, we need to
 change the usage of pseudo_exec_path()

In the next step, to support scripts and native executables, we need to
be able to tweak args. So we change the prototype and usage now.

Signed-off-by: nxa15299 <Heinz.Wrobel@nxp.com>
---
 ports/common/guts/execv.c  | 32 +++++++++++++++-----------------
 ports/common/guts/execve.c | 34 ++++++++++++++++------------------
 ports/common/guts/execvp.c | 34 ++++++++++++++++------------------
 pseudo_client.c            |  4 ++--
 pseudo_client.h            |  2 +-
 5 files changed, 50 insertions(+), 56 deletions(-)

diff --git a/ports/common/guts/execv.c b/ports/common/guts/execv.c
index c071626..908f013 100644
--- a/ports/common/guts/execv.c
+++ b/ports/common/guts/execv.c
@@ -6,27 +6,25 @@
  * wrap_execv(const char *file, char *const *argv) {
  *	int rc = -1;
  */
-	/* note:  we don't canonicalize this, because we are intentionally
-	 * NOT redirecting execs into the chroot environment.  If you try
-	 * to execute /bin/sh, you get the actual /bin/sh, not
-	 * <CHROOT>/bin/sh.  This allows use of basic utilities.  This
-	 * design will likely be revisited.
-	 */
+	const char *path_guess = file;
 	if (antimagic == 0) {
-		const char *path_guess = pseudo_exec_path(file, 0);
-                pseudo_client_op(OP_EXEC, PSA_EXEC, -1, -1, path_guess, 0);
+		path_guess = pseudo_exec_path(&file, 0, &argv);
+		pseudo_client_op(OP_EXEC, PSA_EXEC, -1, -1, path_guess, 0);
 	}
 
-	pseudo_setupenv();
-	if (pseudo_has_unload(NULL)) {
-		/* and here we attach */
-		pseudo_dropenv();
+	if (path_guess) {
+		pseudo_setupenv();
+		if (pseudo_has_unload(NULL))
+			pseudo_dropenv();
+
+		/* if exec() fails, we may end up taking signals unexpectedly...
+		 * not much we can do about that.
+		 */
+		sigprocmask(SIG_SETMASK, &pseudo_saved_sigmask, NULL);
+		rc = real_execv(path_guess, argv);
 	}
-	/* if exec() fails, we may end up taking signals unexpectedly...
-	 * not much we can do about that.
-	 */
-	sigprocmask(SIG_SETMASK, &pseudo_saved_sigmask, NULL);
-	rc = real_execv(file, argv);
+	else
+		errno = ENOENT;
 
 /*	return rc;
  * }
diff --git a/ports/common/guts/execve.c b/ports/common/guts/execve.c
index 24cc177..83752d3 100644
--- a/ports/common/guts/execve.c
+++ b/ports/common/guts/execve.c
@@ -6,27 +6,25 @@
  * wrap_execve(const char *file, char *const *argv, char *const *envp) {
  *	int rc = -1;
  */
-	char * const *new_environ;
-	/* note:  we don't canonicalize this, because we are intentionally
-	 * NOT redirecting execs into the chroot environment.  If you try
-	 * to execute /bin/sh, you get the actual /bin/sh, not
-	 * <CHROOT>/bin/sh.  This allows use of basic utilities.  This
-	 * design will likely be revisited.
-	 */
+	const char *path_guess = file;
         if (antimagic == 0) {
-		const char *path_guess = pseudo_exec_path(file, 0);
-                pseudo_client_op(OP_EXEC, PSA_EXEC, -1, -1, path_guess, 0);
-        }
+		path_guess = pseudo_exec_path(&file, 0, &argv);
+		pseudo_client_op(OP_EXEC, PSA_EXEC, -1, -1, path_guess, 0);
+	}
 
-	new_environ = pseudo_setupenvp(envp);
-	if (pseudo_has_unload(new_environ))
-		new_environ = pseudo_dropenvp(new_environ);
+	if (path_guess) {
+		char * const *new_environ = pseudo_setupenvp(envp);
+		if (pseudo_has_unload(new_environ))
+			new_environ = pseudo_dropenvp(new_environ);
 
-	/* if exec() fails, we may end up taking signals unexpectedly...
-	 * not much we can do about that.
-	 */
-	sigprocmask(SIG_SETMASK, &pseudo_saved_sigmask, NULL);
-	rc = real_execve(file, argv, new_environ);
+		/* if exec() fails, we may end up taking signals unexpectedly...
+		 * not much we can do about that.
+		 */
+		sigprocmask(SIG_SETMASK, &pseudo_saved_sigmask, NULL);
+		rc = real_execve(path_guess, argv, new_environ);
+	}
+	else
+		errno = ENOENT;
 
 /*	return rc;
  * }
diff --git a/ports/common/guts/execvp.c b/ports/common/guts/execvp.c
index e6bf09f..cb8e29a 100644
--- a/ports/common/guts/execvp.c
+++ b/ports/common/guts/execvp.c
@@ -6,27 +6,25 @@
  * wrap_execvp(const char *file, char *const *argv) {
  *     int rc = -1;
  */
-
-	/* note:  we don't canonicalize this, because we are intentionally
-	 * NOT redirecting execs into the chroot environment.  If you try
-	 * to execute /bin/sh, you get the actual /bin/sh, not
-	 * <CHROOT>/bin/sh.  This allows use of basic utilities.  This
-	 * design will likely be revisited.
-	 */
+	const char *path_guess = file;
         if (antimagic == 0) {
-		const char *path_guess = pseudo_exec_path(file, 1);
-                pseudo_client_op(OP_EXEC, PSA_EXEC, -1, -1, path_guess, 0);
-        }
+		path_guess = pseudo_exec_path(&file, 1, &argv);
+		pseudo_client_op(OP_EXEC, PSA_EXEC, -1, -1, path_guess, 0);
+	}
 
-	pseudo_setupenv();
-	if (pseudo_has_unload(NULL))
-		pseudo_dropenv();
+	if (path_guess) {
+		pseudo_setupenv();
+		if (pseudo_has_unload(NULL))
+			pseudo_dropenv();
 
-	/* if exec() fails, we may end up taking signals unexpectedly...
-	 * not much we can do about that.
-	 */
-	sigprocmask(SIG_SETMASK, &pseudo_saved_sigmask, NULL);
-	rc = real_execvp(file, argv);
+		/* if exec() fails, we may end up taking signals unexpectedly...
+		 * not much we can do about that.
+		 */
+		sigprocmask(SIG_SETMASK, &pseudo_saved_sigmask, NULL);
+		rc = real_execvp(path_guess, argv);
+	}
+	else
+		errno = ENOENT;
 
 /*     return rc;
  * }
diff --git a/pseudo_client.c b/pseudo_client.c
index 50a98fa..44402fc 100644
--- a/pseudo_client.c
+++ b/pseudo_client.c
@@ -2093,8 +2093,8 @@ static ssize_t isexecutable(const char *filename, char *buf, ssize_t bufsize)
 }
 
 const char *
-pseudo_exec_path(const char *filename, int search_path) {
-    char *s;
+pseudo_exec_path(const char **filenamep, int search_path, char * const**argvp) {
+	const char *filename = *filenamep, *s;
 	char *path = getenv("PATH");
 	const char *candidate;
 	int i;
diff --git a/pseudo_client.h b/pseudo_client.h
index 28b23dc..c9f6b1a 100644
--- a/pseudo_client.h
+++ b/pseudo_client.h
@@ -70,7 +70,7 @@ extern int (*pseudo_real_execv)(const char *, char * const *);
 extern int pseudo_client_getcwd(void);
 extern int pseudo_client_chroot(const char *);
 extern char *pseudo_root_path(const char *, int, int, const char *, int);
-extern const char *pseudo_exec_path(const char *filename, int);
+extern const char *pseudo_exec_path(const char **filenamep, int, char * const**argvp);
 #define PSEUDO_ROOT_PATH(x, y, z) pseudo_root_path(__func__, __LINE__, (x), (y), (z));
 extern char *pseudo_cwd;
 extern size_t pseudo_cwd_len;
-- 
2.15.1

