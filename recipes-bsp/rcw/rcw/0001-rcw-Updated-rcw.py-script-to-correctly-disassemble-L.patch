From 20298ac4a9eaba5f50e78a5803c4c6747e0ff706 Mon Sep 17 00:00:00 2001
From: Heinz Wrobel <Heinz.Wrobel@nxp.com>
Date: Wed, 17 May 2017 09:25:42 +0200
Subject: [PATCH 1/2] rcw: Updated rcw.py script to correctly disassemble
 LS1012A RCWs/PBIs

This means adding %littleendian64b, fixing handling of the broken final
CRC command, fixing up "wait" generation in the prior code base, and
cleaning up field handling by generating the rcw bitstream for disassembly
now in an int like format with lsb on the right consistently
---
 rcw.py | 96 +++++++++++++++++++++++++++++++++++++++++++++++++++---------------
 1 file changed, 74 insertions(+), 22 deletions(-)

diff --git a/rcw.py b/rcw.py
index dabb959..1e374ad 100755
--- a/rcw.py
+++ b/rcw.py
@@ -306,7 +306,7 @@ def build_pbi(lines):
                 v1 = struct.pack(endianess + 'L', 0x80820000 | p1)
                 subsection += v1
             else:
-                v1 = struct.pack(endianess + 'L', 0x090000c0 |  int(vars['pbladdr']))
+                v1 = struct.pack(endianess + 'L', 0x090000c0 |  (int(vars['pbladdr'], 16) & 0x00ffff00))
                 v2 = struct.pack(endianess + 'L', p1)
                 subsection += v1
                 subsection += v2
@@ -374,7 +374,7 @@ def build_pbi(lines):
             subsection += v3
             subsection += v4
         elif op == 'flush':
-            subsection += struct.pack('>LL', 0x09000000 | int(vars['pbladdr'], 16), 0)
+            subsection += struct.pack('>LL', 0x09000000 | (int(vars['pbladdr'], 16) & 0x00ffff00), 0)
         else:
             print 'Unknown PBI subsection command "%s"' % l
             return ''
@@ -428,7 +428,7 @@ def parse_source_file(source):
             continue
 
         # Is it an identifier?  %var=value
-        m = re.search(r'%([a-zA-Z]+)=(.+)', l)
+        m = re.search(r'%([a-zA-Z]+[a-zA-Z0-9]+)=(.+)', l)
         if m:
             identifier, value = m.groups()
             vars[identifier] = value
@@ -534,7 +534,7 @@ def check_vars():
             pass
         else:
             # If we want the PBL header/footer, the vars for those must be defined
-            if not vars['sysaddr']:
+            if not 'sysaddr' in vars:
                 print 'Error: PBL format requires %sysaddr to be defined'
                 sys.exit(1)
 
@@ -605,7 +605,7 @@ def create_binary():
             binary += struct.pack(endianess + 'L', 0x80100000)
         else:
             length_byte = (((size / 8) & 63) << 1) | 1
-            binary += struct.pack(endianess + 'L', (length_byte << 24) | int(vars['sysaddr'], 16))
+            binary += struct.pack(endianess + 'L', (length_byte << 24) | (int(vars['sysaddr'], 16) & 0x00ffffff))
 
     # Then convert 'bits' into an array of bytes
     for i in range(size - 8, -1, -8):
@@ -638,7 +638,7 @@ def create_binary():
             invert = 0xffffffff
         else:
             crcbinary = binary
-            cmd = binascii.unhexlify('08'+vars['pbladdr'][0:3]+'040')
+            cmd = struct.pack(endianess + 'L', 0x08000040 | (int(vars['pbladdr'], 16) & 0x00ffff00))
             invert = 0
 
         crcbinary += cmd
@@ -685,8 +685,21 @@ def create_source():
     else:
         classicbitnumbers = 0
     endianess = ">"
+    endianessrev = "<"
     if 'littleendian' in vars and int(vars['littleendian'], 0):
-        endianess = "<"
+        newbinary = ''
+        for i in range(0, len(binary), 4):
+                x32 = struct.unpack('>L', binary[i:i + 4])[0]
+                newbinary += struct.pack('<L', x32)
+        binary = newbinary
+
+    # Re-sort words in 64b quads
+    if 'littleendian64b' in vars and int(vars['littleendian64b'], 0):
+        newbinary = ''
+        for i in range(0, len(binary), 8):
+                x64 = struct.unpack('>Q', binary[i:i + 8])[0]
+                newbinary += struct.pack('<Q', x64)
+        binary = newbinary
 
     # Insert the #include statement for the RCWI file.  We assume that the
     # file will be in the include path, so we use <> and strip any paths
@@ -706,12 +719,18 @@ def create_source():
                 bitbytes = rcw
                 # We skip the checksum field
                 pbi = binary[8 + (size / 8) + 4:]
+            else:
+                print 'Weird binary RCW format!'
+                bitbytes = ''
         else:
             if binary[0:4] == preambletst:
                 # Convert the binary into a large integer
                 rcw = binary[8:8 + (size / 8)]
                 bitbytes = rcw
                 pbi = binary[8 + (size / 8):]
+            else:
+                print 'Weird binary RCW format!'
+                bitbytes = ''
     else:
         bitbytes = binary
         pbi = ''
@@ -725,7 +744,11 @@ def create_source():
             newbitbytes += chr(int(bin(byte)[2:].zfill(8)[::-1], 2))
         bitbytes = newbitbytes
 
-    bits = int(binascii.hexlify(bitbytes), 16)
+    # After this stage, all the RCW bits should be formatted with lsb on
+    # the right side and msb on the left side to permit conversion into
+    # a very long uint.
+    bitstring = ''.join(['{0:08b}'.format(ord(x)) for x in bitbytes])[::-1]
+    bits = int(bitstring, 2)
 
     # Loop over all the known symbols
     for n, [bb, ee] in symbols.ordered_items():
@@ -733,16 +756,19 @@ def create_source():
         e = max(bb, ee)
         s = 1 + e - b       # number of bits in field
 
-        shift = (size - 1) - e  # number of bits to shift
+        shift = b  # number of bits to shift defined by lsb
         mask = ((1 << s) - 1)
         v = (bits >> shift) & mask
-        # If we treat the bitfield as "classic" numbered, reverse
+        # If we treat the bitfield as "ppc" numbered, reverse
         # the value before adding it!
-        if b != bb:
+        if b == bb:
             v = int(bin(v)[2:].zfill(s)[::-1], 2)
 
         if v:
-            source += "%s=%u\n" % (n, v)
+            if s > 8:
+                source += "%s=0x%x\n" % (n, v)
+            else:
+                source += "%s=%u\n" % (n, v)
 
             # Clear out the bits we just parsed, so that we can see if
             # there are any left over.  If there are, then it means that
@@ -751,13 +777,14 @@ def create_source():
 
     if bits:
         print 'Unknown bits in positions:',
-        mask = 1 << (size - 1)
+        mask = 1
         n = 0
-        while mask:
+        while bits:
             if (bits & mask):
                 print n,
             n += 1
-            mask >>= 1
+            bits &= ~mask
+            mask <<= 1
         print
 
     if len(pbi) > 0:
@@ -858,18 +885,43 @@ def create_source():
                     source += "/* Unknown word 0x%08x */\n" % (word)
             else:
                 # Traditional pbi format
+
                 hdr = (word & 0xff000000) >> 24
-                if (hdr & 0x01) == 0x01:
-                    if (hdr & 0x80) == 0x80:
-                        source += "a"
-                    source += "write 0x%08x" % (word & 0x00ffffff)
+
+                # Magic hack to overcome broken binary PBI entries
+                # shipping in the SDK for LS1
+                pbladdr = (int(vars['pbladdr'], 16) & 0x00ffff00)
+                crcstopcheck = 0x08000040 | pbladdr
+                if ('littleendian64b' in vars and int(vars['littleendian64b'], 0) and
+                    i + 4 == l and struct.unpack(endianessrev + 'L', pbi[i:i+4])[0] == crcstopcheck):
+                    source += "/* CRC and Stop command (CRC 0x%08x)*/\n" % (word)
+                    i += 4
+                elif (hdr & 0x01) == 0x01:
+                    addr = word & 0x00ffffff
                     cnt = (hdr >> 1) & 0x3f
                     if cnt == 0:
                         cnt = 64
-                    for j in range(0, cnt, 4):
+                    if i + cnt >= l:
+                        print 'Error in write 0x%08x at offset %d within PBI\n' % (word, i)
+                    if (addr & 0x00ffff00 == pbladdr):
                         arg1 = struct.unpack(endianess + 'L', pbi[i:i+4])[0]
                         i += 4
-                        source += ",0x%08x" % (arg1)
+                        if (addr & 0xff == 0x00):
+                            source += "flush"
+                        elif (addr & 0xff == 0x40):
+                            source += "/* CRC command (CRC 0x%08x)*/" % (arg1)
+                        elif (addr & 0xff == 0x80):
+                            source += "jump 0x%08x" %(arg1)
+                        elif (addr & 0xff == 0xc0):
+                            source += "wait %u" %(arg1)
+                    else:
+                        if (hdr & 0x80) == 0x80:
+                            source += "a"
+                        source += "write 0x%08x" % (addr)
+                        for j in range(0, cnt, 4):
+                            arg1 = struct.unpack(endianess + 'L', pbi[i:i+4])[0]
+                            i += 4
+                            source += ",0x%08x" % (arg1)
                     source += "\n"
                 elif (hdr & 0x81) == 0x00:
                     arg1 = struct.unpack(endianess + 'L', pbi[i:i+4])[0]
@@ -894,7 +946,7 @@ command_line()
 
 symbols = {}
 assignments = {}
-vars = {'pbladdr':'138000'}
+vars = {'pbladdr':'0x138000'}
 pbi = ''
 
 if options.reverse:
-- 
1.7.12.4

