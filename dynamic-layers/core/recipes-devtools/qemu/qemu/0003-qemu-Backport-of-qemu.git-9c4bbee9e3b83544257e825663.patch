From 62da543ffa95f427331653ace7eebf9ac5f43e99 Mon Sep 17 00:00:00 2001
From: Heinz Wrobel <Heinz.Wrobel@nxp.com>
Date: Thu, 20 Dec 2018 14:20:02 +0200
Subject: [PATCH] qemu: Backport of
 qemu.git-9c4bbee9e3b83544257e82566342c29e15a88637

No functional change to the original patch

Signed-off-by: nxa15299 <Heinz.Wrobel@nxp.com>
Signed-off-by: Costea Ciprian <ciprianmarian.costea@nxp.com>
---
 accel/tcg/translate-all.c | 49 +++++++++++++++++++++++++++++------------------
 accel/tcg/user-exec.c     | 13 ++++++++++++-
 2 files changed, 42 insertions(+), 20 deletions(-)

diff --git a/accel/tcg/translate-all.c b/accel/tcg/translate-all.c
index e7f0329..1b34964 100644
--- a/accel/tcg/translate-all.c
+++ b/accel/tcg/translate-all.c
@@ -2182,29 +2182,40 @@ int page_unprotect(target_ulong address, uintptr_t pc)
 
     /* if the page was really writable, then we change its
        protection back to writable */
-    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {
-        host_start = address & qemu_host_page_mask;
-        host_end = host_start + qemu_host_page_size;
-
-        prot = 0;
+    if (p->flags & PAGE_WRITE_ORG) {
         current_tb_invalidated = false;
-        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {
-            p = page_find(addr >> TARGET_PAGE_BITS);
-            p->flags |= PAGE_WRITE;
-            prot |= p->flags;
-
-            /* and since the content will be modified, we must invalidate
-               the corresponding translated code. */
-            current_tb_invalidated |= tb_invalidate_phys_page(addr, pc);
-#ifdef CONFIG_USER_ONLY
-            if (DEBUG_TB_CHECK_GATE) {
-                tb_invalidate_check(addr);
+        if (p->flags & PAGE_WRITE) {
+            /* If the page is actually marked WRITE then assume this is because
+             * this thread raced with another one which got here first and
+             * set the page to PAGE_WRITE and did the TB invalidate for us.
+             */
+#ifdef TARGET_HAS_PRECISE_SMC
+            TranslationBlock *current_tb = tb_find_pc(pc);
+            if (current_tb) {
+                current_tb_invalidated = tb_cflags(current_tb) & CF_INVALID;
             }
 #endif
-        }
-        mprotect((void *)g2h(host_start), qemu_host_page_size,
-                 prot & PAGE_BITS);
+        } else {
+            host_start = address & qemu_host_page_mask;
+            host_end = host_start + qemu_host_page_size;
+
+            prot = 0;
+            for (addr = host_start; addr < host_end; addr += TARGET_PAGE_SIZE) {
+                p = page_find(addr >> TARGET_PAGE_BITS);
+                p->flags |= PAGE_WRITE;
+                prot |= p->flags;
+                /* and since the content will be modified, we must invalidate
+                 the corresponding translated code. */
+                current_tb_invalidated |= tb_invalidate_phys_page(addr, pc);
 
+#ifdef DEBUG_TB_CHECK
+                    tb_invalidate_check(addr);
+#endif
+
+            }
+            mprotect((void *)g2h(host_start), qemu_host_page_size,
+                    prot & PAGE_BITS);
+        } 
         mmap_unlock();
         /* If current TB was invalidated return to main loop */
         return current_tb_invalidated ? 2 : 1;
diff --git a/accel/tcg/user-exec.c b/accel/tcg/user-exec.c
index f42285e..3b3f1df 100644
--- a/accel/tcg/user-exec.c
+++ b/accel/tcg/user-exec.c
@@ -103,7 +103,18 @@ static inline int handle_cpu_signal(uintptr_t pc, unsigned long address,
            pc, address, is_write, *(unsigned long *)old_set);
 #endif
     /* XXX: locking issue */
-    if (is_write && h2g_valid(address)) {
+    if (is_write && info->si_signo == SIGSEGV && info->si_code == SEGV_ACCERR &&
+        h2g_valid(address)) {
+        /* Note that it is important that we don't call page_unprotect() unless
+         * this is really a "write to nonwriteable page" fault, because
+         * page_unprotect() assumes that if it is called for an access to
+         * a page that's writeable this means we had two threads racing and
+         * another thread got there first and already made the page writeable;
+         * so we will retry the access. If we were to call page_unprotect()
+         * for some other kind of fault that should really be passed to the
+         * guest, we'd end up in an infinite loop of retrying the faulting
+         * access.
+         */
         switch (page_unprotect(h2g(address), pc)) {
         case 0:
             /* Fault not caused by a page marked unwritable to protect
-- 
1.9.1

